# 開発ガイドライン（完全版）

*オリジナル: https://www.dzombak.com/blog/2025/08/getting-good-results-from-claude-code/*

## 開発哲学

### 核となる信念

- **大規模な変更より段階的な進歩を重視** 
  - コンパイルが通り、テストが成功する小さな変更を積み重ねる
  
- **既存コードから学ぶ** 
  - 実装前に既存のコードを調査し、計画を立てる
  
- **教条主義より実用主義** 
  - プロジェクトの現実に適応する
  
- **巧妙なコードより明確な意図** 
  - 退屈で明白なコードを選ぶ

### シンプルさとは

- 関数/クラスごとに単一の責任を持たせる
- 早すぎる抽象化を避ける
- 巧妙なトリックは使わない - 退屈な解決策を選ぶ
- 説明が必要なら、それは複雑すぎる

## 開発プロセス

### 1. 計画とステージング

複雑な作業を3〜5段階に分割し、`IMPLEMENTATION_PLAN.md`に文書化する：

```markdown
## ステージ N: [名前]
**目標**: [具体的な成果物]
**成功基準**: [テスト可能な成果]
**テスト**: [具体的なテストケース]
**ステータス**: [未着手|進行中|完了]
```

- 進捗に応じてステータスを更新
- すべてのステージが完了したらファイルを削除

### 2. 実装フロー

1. **理解する** - コードベースの既存パターンを調査
2. **テストを書く** - まずテストを書く（レッド）
3. **実装する** - テストが通る最小限のコード（グリーン）
4. **リファクタリング** - テストが通った状態でクリーンアップ
5. **コミット** - 計画にリンクした明確なメッセージでコミット

### 3. 行き詰まった時（3回試した後）

**重要**: 問題ごとに最大3回試行し、その後は停止する。

1. **失敗したことを文書化**：
   - 何を試したか
   - 具体的なエラーメッセージ
   - なぜ失敗したと思うか

2. **代替案を調査**：
   - 2〜3個の類似実装を見つける
   - 使用されている異なるアプローチを記録

3. **基本的な前提を疑う**：
   - これは適切な抽象化レベルか？
   - より小さな問題に分割できるか？
   - より単純なアプローチはないか？

4. **異なる角度から試す**：
   - 異なるライブラリ/フレームワークの機能を使えるか？
   - 異なるアーキテクチャパターンを使えるか？
   - 抽象化を追加する代わりに削除できないか？

## 技術標準

### アーキテクチャの原則

- **継承より合成** - 依存性注入を使用する
- **シングルトンよりインターフェース** - テスト可能性と柔軟性を確保
- **暗黙的より明示的** - データフローと依存関係を明確に
- **可能な限りテスト駆動** - テストを無効化せず、修正する

### コード品質

- **すべてのコミットは必ず**：
  - コンパイルが成功すること
  - 既存のすべてのテストが通ること
  - 新機能のテストが含まれること
  - プロジェクトのフォーマット/リンティングに従うこと

- **コミット前に**：
  - フォーマッター/リンターを実行
  - 変更内容を自己レビュー
  - コミットメッセージで「なぜ」を説明

### エラー処理

- 説明的なメッセージで早期に失敗させる
- デバッグ用のコンテキストを含める
- 適切なレベルでエラーを処理する
- 例外を黙って握りつぶさない

## 意思決定フレームワーク

複数の有効なアプローチが存在する場合、以下に基づいて選択：

1. **テスト可能性** - これを簡単にテストできるか？
2. **可読性** - 6ヶ月後に誰かがこれを理解できるか？
3. **一貫性** - プロジェクトのパターンと一致するか？
4. **シンプルさ** - 動作する最も単純な解決策か？
5. **可逆性** - 後で変更するのはどれくらい難しいか？

## プロジェクトへの統合

### コードベースの学習

- 類似の機能/コンポーネントを3つ見つける
- 共通のパターンと規約を特定する
- 可能な限り同じライブラリ/ユーティリティを使用
- 既存のテストパターンに従う

### ツーリング

- プロジェクトの既存ビルドシステムを使用
- プロジェクトのテストフレームワークを使用
- プロジェクトのフォーマッター/リンター設定を使用
- 強い正当性なしに新しいツールを導入しない

## 品質ゲート

### 完了の定義

- [ ] テストが書かれ、通っている
- [ ] コードがプロジェクトの規約に従っている
- [ ] リンター/フォーマッターの警告がない
- [ ] コミットメッセージが明確
- [ ] 実装が計画と一致している
- [ ] Issue番号なしのTODOがない

### テストガイドライン

- 実装ではなく振る舞いをテストする
- 可能な限り1テストにつき1アサーション
- シナリオを説明する明確なテスト名
- 既存のテストユーティリティ/ヘルパーを使用
- テストは決定的であるべき（毎回同じ結果）

## 重要な注意事項

**絶対にやってはいけないこと**：
- コミットフックを回避するために `--no-verify` を使用
- テストを修正する代わりに無効化
- コンパイルが通らないコードをコミット
- 仮定を立てる - 既存のコードで検証する

**常に行うべきこと**：
- 動作するコードを段階的にコミット
- 進行に応じて計画文書を更新
- 既存の実装から学ぶ
- 3回失敗したら停止して再評価

---

## 実践的な適用

### チェックリスト例

#### 新機能追加時
1. [ ] 類似機能を3つ調査した
2. [ ] IMPLEMENTATION_PLAN.mdを作成した
3. [ ] テストファーストで実装した
4. [ ] 既存のパターンに従った
5. [ ] ドキュメントを更新した

#### バグ修正時
1. [ ] 再現テストを書いた
2. [ ] 最小限の修正を行った
3. [ ] 関連テストが全て通った
4. [ ] 根本原因を文書化した

### トラブルシューティング記録テンプレート

```markdown
## 問題: [簡潔な説明]
**発生日時**: YYYY-MM-DD
**影響範囲**: [どの機能/ユーザーに影響するか]

### 試行1
- **アプローチ**: [何を試したか]
- **結果**: [何が起きたか]
- **エラー**: [具体的なエラーメッセージ]
- **所要時間**: [どれくらいかかったか]

### 試行2
- **アプローチ**: [異なる方法]
- **結果**: [結果]
- **エラー**: [エラー詳細]
- **所要時間**: [時間]

### 試行3
- **アプローチ**: [さらに異なる方法]
- **結果**: [結果]
- **エラー**: [エラー詳細]
- **所要時間**: [時間]

### 分析
- **根本原因の推測**: 
- **学んだこと**: 
- **代替アプローチ**: 
- **推奨される次のステップ**: 
```

## まとめ

このガイドラインの本質は、**質の高いコードを一貫して生産する**ことです。

### 成功の鍵
1. **小さく始める** - 巨大な変更を避ける
2. **既存から学ぶ** - 車輪の再発明をしない
3. **シンプルに保つ** - 複雑さは敵
4. **諦め時を知る** - 3回ルールを守る
5. **品質を妥協しない** - テストとレビューを怠らない

これらの原則を守ることで、保守性が高く、理解しやすく、拡張可能なコードベースを維持できます。